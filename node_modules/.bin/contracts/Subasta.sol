pragma solidity 0.5.8;

contract Subasta {
    //identificadores
    address payable provider;

    //valores puja
    uint precio_inicial;                                   //precio inicial de la puja
    uint precio_actual;                                    //precio maximo que se ha pujado
    address pujador_mas_alto;                              //identificador del pujador más alto
   
    bool puja_cerrada;                                      //indica si la puja ha acabado
    uint hora_inicial;                                      //hora a la que se empieza la puja --> now del momento de creación
    uint duracion;                                          //tiempo que debe estar la puja activa
    mapping(address => uint) devoluciones_pendientes;      //para poder devolver el dinero a los pujadores superados
    
    //valores contrato
    struct Contrato{
        uint id_contrato;
        uint precio_final;
        uint fecha_inicial;
        uint fecha_final;  
        string tipo_energia;
        uint permanencia_meses;
        uint potencia_suministrada;
    }

    Contrato nuevo_contrato;
    
    struct Array_contratos{
        Contrato[] contratos;
    }
    mapping(address => Array_contratos) usuario_contratos;    // map de cada usuario con su correspondiente array de contratos. El ultimo es el actual.

    //Eventos
    event NuevaPujaMasAlta(address pujador, uint valor);
    event PujaAcabada(address ganador, uint valor);



    function finalizarcontrato(address usuario) public{
        uint index = usuario_contratos[usuario].contratos.length - 1;
        usuario_contratos[usuario].contratos[index].fecha_final = now;

    }

   //Crea subasta
   function SimpleAuction(uint _tiempo, address payable _provider, uint _precio_inicial, string memory _tipo_energia, uint _permanencia_meses, uint _potencia_suministrada) public{
        provider = _provider;
        hora_inicial = now;
        duracion = _tiempo;                 
        nuevo_contrato.tipo_energia = _tipo_energia;      
        nuevo_contrato.permanencia_meses = _permanencia_meses;
        nuevo_contrato.potencia_suministrada = _potencia_suministrada;
        precio_actual = precio_inicial = _precio_inicial ; //que la puja mas alta al empezar sea la inicial
    }

   
   
   
   
   
   /// Puja en la subasta con el valor enviado en la misma transacción.
   /// El valor pujado sólo será devuelto si la puja no es ganadora.
   function puja() public payable {
        require(now <= (hora_inicial + duracion));
        require(msg.value > precio_actual);
        if (pujador_mas_alto != address(0)) {
            devoluciones_pendientes[pujador_mas_alto] += precio_actual;
        }
        pujador_mas_alto = msg.sender;
        precio_actual = msg.value;
        emit NuevaPujaMasAlta(msg.sender, msg.value); //fire del evento
    }


    /// Retira una puja que fue superada.
    function retirar() public returns (bool) {
        uint256 amount = devoluciones_pendientes[msg.sender];
        if (amount > 0) {
            devoluciones_pendientes[msg.sender] = 0;
            if (!msg.sender.send(amount)) {   //al comprobar el if se envia el dinero al sender de la funcion
                // Aquí no es necesario lanzar una excepción.
                // Basta con reiniciar la cantidad que se debe devolver.
                devoluciones_pendientes[msg.sender] = amount;
                return false;
            }
        }
        return true;
    }
   
    /// Finaliza la subasta y envía la puja más alta al beneficiario.
    function finPuja() public {
        require(now >= (hora_inicial + duracion));                         // la subasta aún no ha acabado
        require(!puja_cerrada);                                            // esta función ya ha sido llamada
        puja_cerrada= true;
        nuevo_contrato.precio_final= precio_actual;
        nuevo_contrato.id_contrato= (usuario_contratos[pujador_mas_alto].contratos.length);   //id del contrato es el index dentro del array
        usuario_contratos[pujador_mas_alto].contratos.push(nuevo_contrato);                   //añade el contrato al array de contratos del usuario
        emit PujaAcabada(pujador_mas_alto, precio_actual);                 //fire del evento

        provider.transfer(precio_actual);   //Al acabar se manda al provider el precio final de la puja
    }
}


