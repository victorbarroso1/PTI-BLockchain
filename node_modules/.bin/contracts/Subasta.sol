pragma solidity 0.5.8;

contract Subasta {
    //identificadores
    //address payable provider;

    //valores puja
    //uint precio_inicial;                                   //precio inicial de la puja
    //uint precio_actual;                                    //precio maximo que se ha pujado
   
    //bool puja_cerrada;                                      //indica si la puja ha acabado
    //uint hora_inicial;                                      //hora a la que se empieza la puja --> now del momento de creación
    //uint duracion;                                          //tiempo que debe estar la puja activa
    //mapping(address => uint) devoluciones_pendientes;      //para poder devolver el dinero a los pujadores superados
    
    //valores contrato
    

    struct Producto{
        address provider;
        uint precio;
        uint fecha_inicial;
        uint fecha_final;
        string tipo_energia;
        uint permanencia_meses;
        uint potencia_suministrada;
    }

    struct Contrato{
        address wallet;
        uint id_contrato;
        Producto product;
    }
    
    struct Array_contratos{
        Contrato[] contratos;
    }
    mapping(address => Array_contratos) usuario_contratos; //map de cada usuario con su correspondiente array de contratos

    //Eventos
    //event NuevaPujaMasAlta(address pujador, uint valor);
    //event PujaAcabada(address ganador, uint valor);

    //los productos son ajenos al comprador
    function nuevo_producto(uint _precio, uint _fecha_inicial, uint _fecha_final, string memory _tipo_energia,
            uint _permanencia_meses, uint _potencia_suministrada) public {
                Producto memory enuevo_producto;
                enuevo_producto.precio = _precio;
                enuevo_producto.fecha_inicial = _fecha_inicial;
                enuevo_producto.fecha_final = _fecha_final;
                enuevo_producto.tipo_energia = _tipo_energia;
                enuevo_producto.permanencia_meses = _permanencia_meses;
                enuevo_producto.potencia_suministrada = _potencia_suministrada;
                enuevo_producto.provider = msg.sender;    //el provider es el que crea el producto

 

    }
    
    //Un contratto es un producto con un comprador
    function nuevo_contrato(Producto memory _producto, address _wallet) public {
                Contrato memory enuevo_contrato;
                enuevo_contrato.wallet = _wallet;            //el comprador
                enuevo_contrato.product = _producto;
                enuevo_contrato.id_contrato = usuario_contratos[_wallet].contratos.length; //id contrato es unica por wallet
                
                usuario_contratos[_wallet].contratos.push(enuevo_contrato);  //añadimos el contrato al array de contratos del usuario
    }

    function comprar(Producto memory _producto) public payable{
        require(msg.value >= _producto.precio);
        address(uint160(_producto.provider)).transfer(msg.value);
        nuevo_contrato(_producto, msg.sender);

    }

    /*
   //Crea subasta
   function SimpleAuction(uint _tiempo, address payable _provider, uint _precio_inicial, string memory _tipo_energia, uint _permanencia_meses, uint _potencia_suministrada) public{
        provider = _provider;
        hora_inicial = now;
        duracion = _tiempo;                 
        nuevo_contrato.tipo_energia = _tipo_energia;      
        nuevo_contrato.permanencia_meses = _permanencia_meses;
        nuevo_contrato.potencia_suministrada = _potencia_suministrada;
        precio_actual = precio_inicial = _precio_inicial ; //que la puja mas alta al empezar sea la inicial
    }
   
   /// Puja en la subasta con el valor enviado en la misma transacción.
   /// El valor pujado sólo será devuelto si la puja no es ganadora.
   function puja() public payable {

        require(now <= (hora_inicial + duracion));
        require(msg.value > precio_actual);
        if (pujador_mas_alto != address(0)) {
            devoluciones_pendientes[pujador_mas_alto] += precio_actual;
        }
        pujador_mas_alto = msg.sender;
        precio_actual = msg.value;
        emit NuevaPujaMasAlta(msg.sender, msg.value); //fire del evento
    }


    /// Retira una puja que fue superada.
    function retirar() public returns (bool) {
        uint256 amount = devoluciones_pendientes[msg.sender];
        if (amount > 0) {
            devoluciones_pendientes[msg.sender] = 0;
            if (!msg.sender.send(amount)) {   //al comprobar el if se envia el dinero al sender de la funcion
                // Aquí no es necesario lanzar una excepción.
                // Basta con reiniciar la cantidad que se debe devolver.
                devoluciones_pendientes[msg.sender] = amount;
                return false;
            }
        }
        return true;
    }
   
    /// Finaliza la subasta y envía la puja más alta al beneficiario.
    function finPuja() public {
        require(now >= (hora_inicial + duracion));                         // la subasta aún no ha acabado
        require(!puja_cerrada);                                            // esta función ya ha sido llamada
        puja_cerrada= true;
        nuevo_contrato.precio_final= precio_actual;
        nuevo_contrato.id_contrato= (usuario_contratos[pujador_mas_alto].contratos.length);   //id del contrato es el index dentro del array
        usuario_contratos[pujador_mas_alto].contratos.push(nuevo_contrato);                   //añade el contrato al array de contratos del usuario
        emit PujaAcabada(pujador_mas_alto, precio_actual);                 //fire del evento

        provider.transfer(precio_actual);   //Al acabar se manda al provider el precio final de la puja
    }
    */
}
    
